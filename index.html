<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Pipe Network Web</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
      background: #000;
    }
    #startBtn {
      position: absolute;
      top: 30%;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 25px;
      border-radius: 10px;
      border: white;
      background: #2196f3;
      color: white;
      cursor: pointer;
      z-index: 10;
    }
  </style>
</head>
<body>
  <button id="startBtn">Start AR</button>
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js";

    let renderer, scene, camera, xrSession;

    // Get user location first
    if ("geolocation" in navigator) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          console.log("Location:", pos.coords.latitude, pos.coords.longitude);
          window.startingLat = pos.coords.latitude;
          window.startingLon = pos.coords.longitude;
        },
        (err) => console.error("Location error:", err),
        { enableHighAccuracy: true }
      );
    }

    document.getElementById("startBtn").addEventListener("click", () => {
      initAR();
      document.getElementById("startBtn").style.display = "none";
    });

    // --- Utility: convert lat/lon difference to meters (approx) ---
      function latLonToMeters(lat1, lon1, lat2, lon2) {
        const R = 6378137; // Earth radius in meters
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const x = dLon * R * Math.cos(lat1 * Math.PI / 180);
        const z = dLat * R;
        return { x, z };
      }

    async function initAR(lat1, lon1, lat2, lon2) {
      if (navigator.xr) {
        const supported = await navigator.xr.isSessionSupported("immersive-ar");
        if (supported) {
          xrSession = await navigator.xr.requestSession("immersive-ar", {
            requiredFeatures: ["hit-test", "local-floor"]
          });

          // Setup Three.js renderer
          renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          renderer.xr.enabled = true;
          renderer.setSize(window.innerWidth, window.innerHeight);
          document.body.appendChild(renderer.domElement);

          // Setup scene
          scene = new THREE.Scene();
          camera = new THREE.PerspectiveCamera();

          // Add light
          const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
          scene.add(light);

          // Compute positions relative to origin
          const p1 = { x: 0, y: -1, z: 0 }; // origin (your device)
          const offset = latLonToMeters(lat1, lon1, lat2, lon2);
          const p2 = { x: offset.x, y: -1, z: offset.z };

          // Make cylinder between p1 and p2
          const material = new THREE.MeshBasicMaterial({ color: 0x0000ff });
          const pipe = makePipe(p1, p2, 0.1, material);
          scene.add(pipe);

          // Start AR
          renderer.xr.setSession(xrSession);
          renderer.setAnimationLoop(() => {
            renderer.render(scene, camera);
          });
        } else {
          alert("immersive-ar not supported on this device/browser");
        }
      } else {
        alert("WebXR not available in this browser");
      }
    }

    // Create a cylinder between two points
      function makePipe(start, end, radius, material) {
        const dir = new THREE.Vector3(end.x - start.x, end.y - start.y, end.z - start.z);
        const len = dir.length();
        const geom = new THREE.CylinderGeometry(radius, radius, len, 16);
        const mesh = new THREE.Mesh(geom, material);

        // Orient the cylinder
        const mid = new THREE.Vector3(
          (start.x + end.x) / 2,
          (start.y + end.y) / 2,
          (start.z + end.z) / 2
        );
        mesh.position.copy(mid);

        const axis = new THREE.Vector3(0, 1, 0);
        mesh.quaternion.setFromUnitVectors(axis, dir.clone().normalize());

        return mesh;
      }

      //My Location
      // const startLat = 21.233309724315895, startLon = 72.8694816629343;
      // const endLat   = 21.233023038050273, endLon   = 72.86949018490134;

      // initXR(startLat, startLon, endLat, endLon);

      
      //On Device Location
      navigator.geolocation.getCurrentPosition(pos => {
        const originLat = pos.coords.latitude;
        const originLon = pos.coords.longitude;

        // Example target location (change this to your pipe end)
        const targetLat = originLat + 0.0001; // ~11m north
        const targetLon = originLon + 0.0001; // ~11m east

        initXR(originLat, originLon, targetLat, targetLon);
      }, err => {
        console.error("Location error:", err);
        });
  </script>
</body>
</html> -->

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Pipe Network Web</title>
    <style>
      html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; }
      #enter-ar { position: absolute;
      top: 30%;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 25px;
      border-radius: 10px;
      border: white;
      background: #2196f3;
      color: white;
      cursor: pointer;
      z-index: 10; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  </head>
  <body>
    <button id="enter-ar">Enter AR</button>
    <script>
      let camera, scene, renderer;

      function makePipe(start, end, radius, material) {
        const dir = new THREE.Vector3(end.x - start.x, end.y - start.y, end.z - start.z);
        const len = dir.length();
        const geom = new THREE.CylinderGeometry(radius, radius, len, 16);
        const mesh = new THREE.Mesh(geom, material);

        // position at midpoint
        const mid = new THREE.Vector3(
          (start.x + end.x) / 2,
          (start.y + end.y) / 2,
          (start.z + end.z) / 2
        );
        mesh.position.copy(mid);

        // rotate cylinder to align with direction
        const axis = new THREE.Vector3(0, 1, 0); // cylinder's default up
        mesh.quaternion.setFromUnitVectors(axis, dir.clone().normalize());

        return mesh;
      }

      async function initXR() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera();

        renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.xr.enabled = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const button = document.getElementById("enter-ar");
        button.addEventListener("click", async () => {
          const session = await navigator.xr.requestSession("immersive-ar", {
            requiredFeatures: ["local"]
          });
          renderer.xr.setSession(session);

          // World-space points (in meters relative to AR origin)
          const p1 = { x: 0, y: -1, z: -2 };   // ~2m in front
          const p2 = { x: 3, y: -1, z: -5 };   // further away

          const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
          const pipe = makePipe(p1, p2, 0.05, material);
          scene.add(pipe);

          // const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
          // scene.add(light);

          renderer.setAnimationLoop(() => {
            renderer.render(scene, camera);
          });
        });
      }

      initXR();
    </script>
  </body>
</html>