<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Pipe Network Web</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
      background: #000;
    }
    #startBtn {
      position: absolute;
      top: 30%;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 25px;
      border-radius: 10px;
      border: white;
      background: #2196f3;
      color: white;
      cursor: pointer;
      z-index: 10;
    }
  </style>
</head>
<body>
  <button id="startBtn">Start AR</button>
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js";

    let renderer, scene, camera, xrSession;

    // Get user location first
    if ("geolocation" in navigator) {
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          console.log("Location:", pos.coords.latitude, pos.coords.longitude);
          window.startingLat = pos.coords.latitude;
          window.startingLon = pos.coords.longitude;
        },
        (err) => console.error("Location error:", err),
        { enableHighAccuracy: true }
      );
    }

    document.getElementById("startBtn").addEventListener("click", () => {
      initAR();
      document.getElementById("startBtn").style.display = "none";
    });

    // --- Utility: convert lat/lon difference to meters (approx) ---
      function latLonToMeters(lat1, lon1, lat2, lon2) {
        const R = 6378137; // Earth radius in meters
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const x = dLon * R * Math.cos(lat1 * Math.PI / 180);
        const z = dLat * R;
        return { x, z };
      }

    async function initAR(lat1, lon1, lat2, lon2) {
      if (navigator.xr) {
        const supported = await navigator.xr.isSessionSupported("immersive-ar");
        if (supported) {
          xrSession = await navigator.xr.requestSession("immersive-ar", {
            requiredFeatures: ["hit-test", "local-floor"]
          });

          // Setup Three.js renderer
          renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          renderer.xr.enabled = true;
          renderer.setSize(window.innerWidth, window.innerHeight);
          document.body.appendChild(renderer.domElement);

          // Setup scene
          scene = new THREE.Scene();
          camera = new THREE.PerspectiveCamera();

          // Add light
          const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
          scene.add(light);

          // Compute positions relative to origin
          const p1 = { x: 0, y: -1, z: 0 }; // origin (your device)
          const offset = latLonToMeters(lat1, lon1, lat2, lon2);
          const p2 = { x: offset.x, y: -1, z: offset.z };

          // Make cylinder between p1 and p2
          const material = new THREE.MeshBasicMaterial({ color: 0x0000ff });
          const pipe = makePipe(p1, p2, 0.1, material);
          scene.add(pipe);

          // Start AR
          renderer.xr.setSession(xrSession);
          renderer.setAnimationLoop(() => {
            renderer.render(scene, camera);
          });
        } else {
          alert("immersive-ar not supported on this device/browser");
        }
      } else {
        alert("WebXR not available in this browser");
      }
    }

    // Create a cylinder between two points
      function makePipe(start, end, radius, material) {
        const dir = new THREE.Vector3(end.x - start.x, end.y - start.y, end.z - start.z);
        const len = dir.length();
        const geom = new THREE.CylinderGeometry(radius, radius, len, 16);
        const mesh = new THREE.Mesh(geom, material);

        // Orient the cylinder
        const mid = new THREE.Vector3(
          (start.x + end.x) / 2,
          (start.y + end.y) / 2,
          (start.z + end.z) / 2
        );
        mesh.position.copy(mid);

        const axis = new THREE.Vector3(0, 1, 0);
        mesh.quaternion.setFromUnitVectors(axis, dir.clone().normalize());

        return mesh;
      }

      //My Location
      // const startLat = 21.233309724315895, startLon = 72.8694816629343;
      // const endLat   = 21.233023038050273, endLon   = 72.86949018490134;

      // initXR(startLat, startLon, endLat, endLon);

      
      //On Device Location
      navigator.geolocation.getCurrentPosition(pos => {
        const originLat = pos.coords.latitude;
        const originLon = pos.coords.longitude;

        // Example target location (change this to your pipe end)
        const targetLat = originLat + 0.0001; // ~11m north
        const targetLon = originLon + 0.0001; // ~11m east

        initXR(originLat, originLon, targetLat, targetLon);
      }, err => {
        console.error("Location error:", err);
        });
  </script>
</body>
</html> -->

<!-- <!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Pipe Network Web</title>
    <style>
      html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; }
      #enter-ar { position: absolute;
      top: 30%;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 25px;
      border-radius: 10px;
      border: white;
      background: #2196f3;
      color: white;
      cursor: pointer;
      z-index: 10; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  </head>
  <body>
    <button id="enter-ar">Enter AR</button>
    <script>
      let camera, scene, renderer;

      function makePipe(start, end, radius, material) {
        const dir = new THREE.Vector3(end.x - start.x, end.y - start.y, end.z - start.z);
        const len = dir.length();
        const geom = new THREE.CylinderGeometry(radius, radius, len, 16);
        const mesh = new THREE.Mesh(geom, material);

        // position at midpoint
        const mid = new THREE.Vector3(
          (start.x + end.x) / 2,
          (start.y + end.y) / 2,
          (start.z + end.z) / 2
        );
        mesh.position.copy(mid);

        // rotate cylinder to align with direction
        const axis = new THREE.Vector3(0, 1, 0); // cylinder's default up
        mesh.quaternion.setFromUnitVectors(axis, dir.clone().normalize());

        return mesh;
      }

      async function initXR() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera();

        renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.xr.enabled = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const button = document.getElementById("enter-ar");
        button.addEventListener("click", async () => {
          const session = await navigator.xr.requestSession("immersive-ar", {
            requiredFeatures: ["local"]
          });
          renderer.xr.setSession(session);

          // World-space points (in meters relative to AR origin)
          const p1 = { x: 0, y: -1, z: -2 };   // ~2m in front
          const p2 = { x: 3, y: -1, z: -5 };   // further away

          const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
          const pipe = makePipe(p1, p2, 0.05, material);
          scene.add(pipe);

          // const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
          // scene.add(light);

          renderer.setAnimationLoop(() => {
            renderer.render(scene, camera);
          });
        });
      }

      initXR();
    </script>
  </body>
</html> -->


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR GPS Cylinder Placement</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 300px;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            z-index: 100;
            text-align: center;
        }
        
        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 12px 20px;
            margin: 5px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #0052a3;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .status {
            color: #00ff00;
        }
        
        .error {
            color: #ff6666;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>WebXR GPS Cylinder Placement</h3>
        <div>Status: <span id="status">Initializing...</span></div>
        <div>GPS: <span id="gps-info">Waiting for location...</span></div>
        <div>Start Distance: <span id="start-distance">-</span></div>
        <div>End Distance: <span id="end-distance">-</span></div>
        <div>Heading: <span id="heading">-</span></div>
    </div>
    
    <div id="controls">
        <button id="ar-button" disabled>Enter AR</button>
    </div>
    
    <canvas id="canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        class WebXRGeoSpatial {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.session = null;
                this.referenceSpace = null;
                
                // GPS and positioning
                this.userPosition = { lat: 0, lon: 0, accuracy: 0 };

                //My Location
                // this.startLocation = { lat: 21.233139, lon: 72.870094 }; 
                // this.endLocation = { lat: 21.233473686451035, lon: 72.86947464171197 };

                //MT Location
                // this.startLocation = { lat: 23.012311506453788, lon: 72.50853881838465 };
                // this.endLocation = { lat: 23.01205681727913, lon: 72.50854382108899 };

                //Prahlad Nagar
                this.startLocation = { lat: 23.011922858010955, lon: 72.50673117375791 };
                this.endLocation = { lat: 23.012034581661045, lon: 72.51075577587946 };

                this.gpsWatcher = null;
                this.compassHeading = 0;
                
                // Single horizontal cylinder (pipe)
                this.pipeCylinder = null;
                this.positionHistory = [];
                this.maxHistorySize = 5;
                
                // Elements
                this.statusEl = document.getElementById('status');
                this.gpsInfoEl = document.getElementById('gps-info');
                this.startDistanceEl = document.getElementById('start-distance');
                this.endDistanceEl = document.getElementById('end-distance');
                this.headingEl = document.getElementById('heading');
                this.arButton = document.getElementById('ar-button');
                
                this.init();
            }
            
            async init() {
                this.updateStatus('Checking WebXR support...');
                
                // Check WebXR support
                if (!navigator.xr) {
                    this.updateStatus('WebXR not supported', true);
                    return;
                }
                
                try {
                    const supported = await navigator.xr.isSessionSupported('immersive-ar');
                    if (!supported) {
                        this.updateStatus('AR not supported on this device', true);
                        return;
                    }
                } catch (error) {
                    this.updateStatus('Error checking AR support: ' + error.message, true);
                    return;
                }
                
                this.setupThreeJS();
                this.setupGPS();
                this.setupCompass();
                this.setupEventListeners();
                
                this.arButton.disabled = false;
                this.updateStatus('Ready for AR');
            }
            
            setupThreeJS() {
                // Scene
                this.scene = new THREE.Scene();
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('canvas'),
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.xr.enabled = true;
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 0.5);
                this.scene.add(directionalLight);
                
                // Create cylinders
                this.createCylinders();
                
                // Start render loop
                this.renderer.setAnimationLoop(() => this.render());
            }
            
            createCylinders() {
                // Single horizontal cylinder (pipe) connecting start to end
                const distance = this.calculateDistance(this.startLocation, this.endLocation);
                const geometry = new THREE.CylinderGeometry(0.5, 0.5, distance, 16); // Smaller radius, length = distance
                const material = new THREE.MeshLambertMaterial({ color: 0xffff00 });
                this.pipeCylinder = new THREE.Mesh(geometry, material);
                
                // Hide pipe initially
                this.pipeCylinder.visible = false;
                
                this.scene.add(this.pipeCylinder);
                
                // Position and orient the pipe (but keep it hidden)
                this.updatePipePosition();
            }
            
            setupGPS() {
                if (!navigator.geolocation) {
                    this.updateStatus('GPS not supported', true);
                    return;
                }
                
                const options = {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 1000
                };
                
                this.gpsWatcher = navigator.geolocation.watchPosition(
                    (position) => this.onGPSUpdate(position),
                    (error) => this.onGPSError(error),
                    options
                );
            }
            
            setupCompass() {
                if ('DeviceOrientationEvent' in window) {
                    window.addEventListener('deviceorientation', (event) => {
                        if (event.alpha !== null) {
                            this.compassHeading = event.alpha;
                            this.headingEl.textContent = Math.round(event.alpha) + 'Â°';
                        }
                    });
                }
            }
            
            setupEventListeners() {
                this.arButton.addEventListener('click', () => this.enterAR());
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            onGPSUpdate(position) {
                const newPos = {
                    lat: position.coords.latitude,
                    lon: position.coords.longitude,
                    accuracy: position.coords.accuracy
                };
                
                // Add to history for smoothing
                this.positionHistory.push(newPos);
                if (this.positionHistory.length > this.maxHistorySize) {
                    this.positionHistory.shift();
                }
                
                // Calculate smoothed position
                this.userPosition = this.calculateSmoothedPosition();
                
                // Update UI
                this.gpsInfoEl.innerHTML = `
                    Lat: ${this.userPosition.lat.toFixed(6)}<br>
                    Lon: ${this.userPosition.lon.toFixed(6)}<br>
                    Accuracy: ${Math.round(this.userPosition.accuracy)}m
                `;
                
                // Update distances
                const startDistance = this.calculateDistance(this.userPosition, this.startLocation);
                const endDistance = this.calculateDistance(this.userPosition, this.endLocation);
                
                this.startDistanceEl.textContent = Math.round(startDistance) + 'm';
                this.endDistanceEl.textContent = Math.round(endDistance) + 'm';
                
                // Update cylinder position
                this.updatePipePosition();
            }
            
            onGPSError(error) {
                this.updateStatus(`GPS Error: ${error.message}`, true);
            }
            
            calculateSmoothedPosition() {
                if (this.positionHistory.length === 0) return this.userPosition;
                
                let totalLat = 0, totalLon = 0, totalWeight = 0;
                
                this.positionHistory.forEach(pos => {
                    const weight = 1 / Math.max(pos.accuracy, 1); // Higher weight for more accurate readings
                    totalLat += pos.lat * weight;
                    totalLon += pos.lon * weight;
                    totalWeight += weight;
                });
                
                return {
                    lat: totalLat / totalWeight,
                    lon: totalLon / totalWeight,
                    accuracy: this.positionHistory[this.positionHistory.length - 1].accuracy
                };
            }
            
            updatePipePosition() {
                if (this.userPosition.lat === 0 || !this.pipeCylinder) return;
                
                // Get world positions of start and end points
                const startPos = this.gpsToWorld(this.userPosition, this.startLocation);
                const endPos = this.gpsToWorld(this.userPosition, this.endLocation);
                
                // Calculate center point between start and end
                const centerX = (startPos.x + endPos.x) / 2;
                const centerY = 0.5; // Slightly above ground
                const centerZ = (startPos.z + endPos.z) / 2;
                
                // Position pipe at center point
                this.pipeCylinder.position.set(centerX, centerY, centerZ);
                
                // Calculate distance and direction
                const dx = endPos.x - startPos.x;
                const dz = endPos.z - startPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                // Update pipe length to match actual distance
                this.pipeCylinder.scale.y = distance / this.calculateDistance(this.startLocation, this.endLocation);
                
                // Rotate pipe to point from start to end
                // Cylinder is vertical by default, so we need to rotate it to be horizontal
                const angle = Math.atan2(dx, dz);
                this.pipeCylinder.rotation.set(Math.PI / 2, 0, angle); // Rotate to horizontal and orient correctly
            }
            
            gpsToWorld(userPos, targetPos) {
                const R = 6371000; // Earth's radius in meters
                
                // Convert to radians
                const userLatRad = userPos.lat * Math.PI / 180;
                const targetLatRad = targetPos.lat * Math.PI / 180;
                const dLat = (targetPos.lat - userPos.lat) * Math.PI / 180;
                const dLon = (targetPos.lon - userPos.lon) * Math.PI / 180;
                
                // Calculate relative position in meters
                const x = dLon * Math.cos(userLatRad) * R;
                const z = dLat * R;
                
                // Apply compass heading rotation
                const heading = (this.compassHeading || 0) * Math.PI / 180;
                const rotatedX = x * Math.cos(-heading) - z * Math.sin(-heading);
                const rotatedZ = x * Math.sin(-heading) + z * Math.cos(-heading);
                
                return { x: rotatedX, y: 0, z: -rotatedZ }; // Negative Z for correct orientation
            }
            
            calculateDistance(pos1, pos2) {
                const R = 6371000; // Earth's radius in meters
                const dLat = (pos2.lat - pos1.lat) * Math.PI / 180;
                const dLon = (pos2.lon - pos1.lon) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(pos1.lat * Math.PI / 180) * Math.cos(pos2.lat * Math.PI / 180) *
                         Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            }
            
            async enterAR() {
                try {
                    this.updateStatus('Starting AR session...');
                    
                    this.session = await navigator.xr.requestSession('immersive-ar', {
                        requiredFeatures: ['local-floor']
                    });
                    
                    this.referenceSpace = await this.session.requestReferenceSpace('local-floor');
                    this.renderer.xr.setSession(this.session);
                    
                    this.session.addEventListener('end', () => {
                        this.updateStatus('AR session ended');
                        this.session = null;
                        this.arButton.textContent = 'Enter AR';
                        
                        // Hide the pipe when AR session ends
                        if (this.pipeCylinder) {
                            this.pipeCylinder.visible = false;
                        }
                    });
                    
                    this.arButton.textContent = 'Exit AR';
                    this.updateStatus('AR session active');
                    
                    // Show the pipe when AR session starts
                    if (this.pipeCylinder) {
                        this.pipeCylinder.visible = true;
                    }
                    
                } catch (error) {
                    this.updateStatus(`Failed to start AR: ${error.message}`, true);
                }
            }
            
            render() {
                if (this.session) {
                    this.updatePipePosition();
                }
                this.renderer.render(this.scene, this.camera);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            updateStatus(message, isError = false) {
                this.statusEl.textContent = message;
                this.statusEl.className = isError ? 'error' : 'status';
                console.log(`Status: ${message}`);
            }
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new WebXRGeoSpatial();
        });
    </script>
</body>
</html>